DESARROLLO DEL CURSO COMPLETO DE SQL, DE LA ACADEMIA VIRTUAL PÍLDORAS INFORMÁTICAS

https://youtu.be/dfF4WAaUX5c

Gestor de bases de datos: Access o MySQL 
MySQL, a través del panel de administración, PhpMyAdmin 
Servidor Xampp.


Si se quiere obtener información de una base de datos, se realiza una solicitud SQL, construyendo una sentencia SQL.
Esta solicitud se le hace al ordenador o al servidor
Y el ordenardor o servidor captura la información requerida y la retorna por la misma vía, al usuario. 

Estándar SQL

Grupos de Comandos SQL
Las sentencias en SQL, se escriben con comandos y estos se dividen en:
DDL (data definition lenguaje): para crear, eliminar, modificar tablas. 
DML (data manipulation lenguaje): seleccionar registros de una base, insertar.  Consultas de acción y selección.
DCL (data control lenguaje): para proporcionar seguridad a la información en la base.
TCL(transaction control lenguaje) : se usa para la gestión de los cambios en los datos. 


(IMAGEN: GRUPOS DE COMANDOS)
(IMAGEN: CLAÚSULAS)

Una instrucción SQL, se compone por:
	• Comandos ya mencionados
	• Clausulas
	• Operadores SQL
	• Funciones de agregado.


(IMAGEN: SINTAXIS DE INSTRUCCIÓN)


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

CLASE 3
CLAÚSULAS


(IMAGEN:CLAÚSULAS)
(IMAGEN:OPERADORES DE COMPARACIÓN)
(IMAGEN:OPERADORES LÓGICOS)

ORDEN DE ESCRITURA COMPLEJA DONDE SE AGLUTINAN TODAS ESTAS CLAÚSULAS:
(IMAGEN: SINTAXIS COMPLEJA)


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CONSULTAS SQL EN CLASE 3 Y 4

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM PRODUCTOS WHERE SECCIÓN="CERÁMICA" 

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM PRODUCTOS WHERE SECCIÓN="CERÁMICA" OR  SECCIÓN="DEPORTES"

SELECT * FROM PRODUCTOS WHERE SECCIÓN="DEPORTES" AND PAÍSDEORIGEN="USA";

SELECT * FROM `PRODUCTOS` WHERE PRECIO>300

SELECT * FROM `productos` WHERE FECHA BETWEEN '2000-03-01' AND '2000-04-30'

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA'

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN                             //ORDENAMOS POR SECCION.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN DESC                  //ORDENAMOS POR SECCION ALFABETICAMENTE.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY PRECIO                              //ORDENAMOS POR PRECIO.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN, PRECIO            //ORDENAMOS POR SECCIÓN Y PRECIO.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN, PRECIO DESC            //ORDENAMOS POR SECCIÓN Y PRECIO, EN FORMA DESCENDENTE.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN, PAÍSDEORIGEN      //ORDENAMOS POR SECCIÓN Y PAÍS DE ORIGEN.

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' OR SECCIÓN='CERÁMICA' ORDER BY SECCIÓN, PAÍSDEORIGEN, PRECIO      //ORDENAMOS POR SECCIÓN, PAÍS DE ORIGEN Y PRECIO.


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

CLASE 5 (CONSULTAS DE AGRUPACIÓN O TOTALES) 
CLASE 6 (CONSULTAS DE CÁLCULO)

INSTRUCCIONES SQL DE LA CLASE 5 Y 6:

SELECT SECCIÓN, SUM(PRECIO) FROM PRODUCTOS GROUP BY SECCIÓN                                                    			      //SUMA DE $$$ POR SECCIÓN.

SELECT SECCIÓN, SUM(PRECIO) AS SUMA_ARTICULOS FROM PRODUCTOS GROUP BY SECCIÓN ORDER BY SUMA_ARTICULOS      			      //ORDENAMOS LA SUMA DE PRECIOS POR SECCIÓN. PARA ESTO CREAMOS UN ALIAS SUMA_ARTICULOS.

SELECT SECCIÓN, AVG(PRECIO) AS MEDIA_ARTICULOS FROM PRODUCTOS GROUP BY SECCIÓN ORDER BY MEDIA_ARTICULOS    			      //ORDENAMOS LA MEDIA DE PRECIOS POR SECCIÓN. PARA ESTO CREAMOS UN ALIAS MEDIA_ARTICULOS. 

SELECT SECCIÓN, AVG(PRECIO) AS MEDIA_ARTICULOS FROM PRODUCTOS GROUP BY SECCIÓN HAVING SECCIÓN='DEPORTES' OR SECCIÓN='CONFECCIÓN'      //LA MEDIA DE $$$ DE SECCIÓN DEPORTES Y CONFECCIÓN.  EN AGRUPACIÓN SE REMPLAZA EL WHERE POR EL HAVING. 

SELECT POBLACIÓN, COUNT(CÓDIGOCLIENTE) AS NUM_CLIENTES FROM CLIENTES GROUP BY POBLACIÓN   					      // CONTAMOS A LOS CLIENTES AGRUPADOS POR POBLACIÓN.

SELECT SECCIÓN, MAX(PRECIO) AS PRECIO_MAS_ALTO FROM PRODUCTOS WHERE SECCIÓN='CONFECCIÓN' GROUP BY SECCIÓN      			      // PRECIO MÁS ALTO DE LA SECCIÓN CONFECCIÓN.  

SELECT SECCIÓN, NOMBREARTÍCULO, MAX(PRECIO) AS PRECIO_MAS_ALTO FROM PRODUCTOS WHERE SECCIÓN='CONFECCIÓN' GROUP BY SECCIÓN   	      //  PRECIO MÁS ALTO DE LA SECCIÓN CONFECCIÓN.  AGREGAMOS EL NOMBRE DEL ARTÍCULO.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, PRECIO*1.21 FROM PRODUCTOS               						      //MUESTRA LOS 3  CAMPOS MENSIONADOS Y CALCULA TAMBN UN IVA DEL 21%.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, PRECIO*1.21 AS PRECIO_CON_IVA FROM PRODUCTOS       					      //MUESTRA LOS 3  CAMPOS MENSIONADOS Y CALCULA TAMBN UN IVA DEL 21%. USA UN ALIAS.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, ROUND(PRECIO*1.21, 2) AS PRECIO_CON_IVA FROM PRODUCTOS  			              //MUESTRA LOS 3  CAMPOS MENSIONADOS Y CALCULA TAMBN UN IVA DEL 21%. USA UN ALIAS. SE REDONDEA A 2 DECIMALES.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, PRECIO-3 AS PRECIO_DTO FROM PRODUCTOS           					      //TODOS LOS PRODUCTOS CON 3 EUROS DE DESCUENTO.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA FROM PRODUCTOS WHERE SECCIÓN='DEPORTES'          					      //ARTÍCULOS DE DEPORTES.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA, NOW() AS DIA_DE_HOY FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' 			      //MUESTRA EL DÍA EN QUE SE HACE LA CONSULTA. SE USA ALIAS.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA, NOW() AS DIA_DE_HOY, DATEDIFF(NOW(),FECHA) FROM PRODUCTOS WHERE SECCIÓN='DEPORTES'     //DÍAS DE DIFERENCIA ENTRE LA FECHA DEL PRODUCTO Y LA ACTUAL.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA, NOW() AS DIA_DE_HOY, DATEDIFF(NOW(),FECHA) AS CANTIDAD_DIAS FROM PRODUCTOS WHERE SECCIÓN='DEPORTES'     			  //DÍAS DE DIFERENCIA ENTRE LA FECHA DEL PRODUCTO Y LA ACTUAL. USANDO ALIAS.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA, DATE_FORMAT(NOW(),'%D-%M') AS DIA_DE_HOY, DATEDIFF(NOW(),FECHA) AS CANTIDAD_DIAS FROM PRODUCTOS WHERE SECCIÓN='DEPORTES'   //A NOW() LE DAMPS UN FORMATO DE DÍA Y MES, SEPARADOS POR GUIÓN.

SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO, FECHA, DATE_FORMAT(NOW(),'%D/%M/%Y') AS DIA_DE_HOY, DATEDIFF(NOW(),FECHA) AS CANTIDAD_DIAS FROM PRODUCTOS WHERE SECCIÓN='DEPORTES'


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 7 
CONSULTAS MULTITABLAS

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' UNION SELECT * FROM PRODUCTOSNUEVOS WHERE SECCIÓN='DEPORTES DE RIESGO'   	   // 2 CONSULTAS UNIDAS

SELECT * FROM PRODUCTOS WHERE PRECIO>500 UNION SELECT * FROM PRODUCTOSNUEVOS WHERE SECCIÓN='ALTA COSTURA'            		   //MUESTRA LOS PRODUCTOS CON $ MAYOR A 500 EUROS DE LA TABLA "PRODUCTOS",  Y LOS PRODUCTOS DE ALTA COSTURA DE LA TABLA PRODUCTOSNUEVOS". 

SELECT * FROM PRODUCTOS WHERE SECCIÓN='DEPORTES' UNION ALL SELECT * FROM PRODUCTOSNUEVOS            				   //UNION ALL CONSIDERA LOS REGISTROS REPETIDOS, MIENTRAS QUE UNION NO CONSIDERA REGISTROS REPETIDOS


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

CLASE 8
CONSULTAS MULTITABLA INNER JOIN 

(IMAGEN: SQL JOINS)


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 9
CONSULTAS MULTITABLA, LEFT JOIN Y RIGHT JOIN 

RELACIONAMOS LAS TABLAS EN MYSQL...

SELECT CLIENTES.CÓDIGOCLIENTE, POBLACIÓN, DIRECCIÓN, NÚMERODEPEDIDO, PEDIDOS.CÓDIGOCLIENTE, FORMADEPAGO FROM CLIENTES INNER JOIN 
PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE WHERE POBLACIÓN='MADRID'

//ESPECIFICACIÓN DEL CAMPO COMÚN ENTRE LAS TABLAS.

SELECT CLIENTES.CÓDIGOCLIENTE, POBLACIÓN, DIRECCIÓN, NÚMERODEPEDIDO, PEDIDOS.CÓDIGOCLIENTE, FORMADEPAGO FROM CLIENTES LEFT JOIN 
PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE WHERE POBLACIÓN='MADRID'

//CON LEFT JOIN APARECEN TAMBN LOS CLIENTES QUE NO HAN HECHO PEDIDOS.


SELECT CLIENTES.CÓDIGOCLIENTE, POBLACIÓN, DIRECCIÓN, NÚMERODEPEDIDO, PEDIDOS.CÓDIGOCLIENTE, FORMADEPAGO FROM CLIENTES LEFT JOIN
PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE WHERE POBLACIÓN='MADRID' AND PEDIDOS.CÓDIGOCLIENTE IS NULL

//CLIENTES DE MADRID QUE NO HAN HECHO PEDIDOS.


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 10
SUBCONSULTAS

SELECT AVG(PRECIO) FROM PRODUCTOS          								 //SUBCONSULTA: NOS DEVUELVE LA MEDIA DEL PRECIO DE LOS PRODUCTOS.

SELECT NOMBREARTÍCULO, SECCIÓN FROM PRODUCTOS WHERE PRECIO > (SELECT AVG(PRECIO) FROM PRODUCTOS)  	 //CONSULTA PADRE Y (CONSULTA HIJO). DEVUELVE LOS PRODUCTOS Q SUPERAN LA MEDIA DEL PRECIO.

-------------

SELECT PRECIO FROM PRODUCTOS WHERE SECCIÓN='CERÁMICA'   						 //SUBCONSULTA: DEVUELVE LOS PRECIOS DE LOS ARTÍCULOS DE LA SECCIÓN CERÁMICA.

SELECT * FROM PRODUCTOS  WHERE PRECIO > ALL (SELECT PRECIO FROM PRODUCTOS WHERE SECCIÓN='CERÁMICA')  	 //DEVUELVE LA INFO DE LOS PRODUCTOS QUE SON SUPERIORES EN $ A  TODOS LOS PRODUCTOS  DE LA SECCIÓN CERÁMICA.

SELECT * FROM PRODUCTOS  WHERE PRECIO > ANY (SELECT PRECIO FROM PRODUCTOS WHERE SECCIÓN='CERÁMICA')      //DEVUELVE LA INFO DE LOS PRODUCTOS QUE SON SUPERIORES EN $ A  CUALQUIERA DE LOS PRODUCTOS  DE LA SECCIÓN CERÁMICA.

-------------

SELECT PRECIO FROM PRODUCTOS WHERE SECCIÓN='JUGUETERÍA'   //PRECIOS DE LOS PRODUCTOS DE JUGUETERÍA.

SELECT * FROM PRODUCTOS WHERE PRECIO > ALL (SELECT PRECIO FROM PRODUCTOS WHERE SECCIÓN='JUGUETERÍA') 	 //DEVULVE LA INFO DE LOS PRODUCTOS, CON PRECIO MAYOR A TODOS LOS PRECIOS DE LOS ARTÍCULOS DE JUGUETERÍA.


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 11
PREDICADOS IN Y NOT IN

//PEDIR EL NOMBRE Y PRECIO DE LOS PRODUCTOS DE LOS QUE SE HAN PEDIDO MÁS DE 20 UNIDADES: 

SELECT NOMBREARTÍCULO, PRECIO FROM PRODUCTOS WHERE CÓDIGO ARTÍCULO IN (SELECT CÓDIGOARTÍCULO FROM PRODUCTOSPEDIDOS WHERE UNIDADES>20)
SELECT NOMBREARTÍCULO, PRECIO FROM PRODUCTOS INNER JOIN PRODUCTOSPEDIDOS ON PRODUCTOS.CÓDIGOARTÍCULO=PRODUCTOSPEDIDOS.CÓDIGOARTÍCULO WHERE UNIDADES>20

-----------

//CLIENTES QUE NO HAN PAGADO CON TARJETA O QUE NO HAN REALIZADO PEDIDOS:

SELECT EMPRESA, POBLACIÓN FROM CLIENTES WHERE CÓDIGOCLIENTE NOT IN (SELECT CÓDIGOCLIENTE FROM PEDIDOS WHERE FORMADEPAGO="TARJETA")


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 12 
CONSULTAS DE ACCIÓN

//DE LA TABLA DE PRODUCTOS SE MODIFICARÁ EL PRECIO. SUMANDOLE 10 EUROS A LOS ARTÍCULOS DE LA SECCIÓN DE DEPORTES:

UPDATE PRODUCTOS  SET PRECIO=PRECIO+10 WHERE SECCIÓN ='DEPORTES'

//CAMBIA EL NOMBRE DE LA SECCIÓN, DE DEPORTER A DEPORTIVOS:

UPDATE PRODUCTOS SET SECCIÓN='DEPORTIVOS' WHERE SECCIÓN='DEPORTES'

-----------

//CREAR UNA TABLA A PARTIR DE OTRA
//TABLA QUE TENGA SOLO CLIENTES DE MADRID:

EN ACCESS>>> SELECT * INTO CLIENTES_MADRID FROM CLIENTES WHERE POBLACIÓN='MADRID'
EN MYSQL>>>  CREATE TABLE CLIENTES_MADRID SELECT * FROM CLIENTES WHERE POBLACIÓN='MADRID'


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 13 
CONSULTAS DE ACCIÓN - ELIMINACIÓN


//ELIMINAR CLIENTES DE MADRID:

EN ACCESS >>> DELETE FROM CLIENTES WHERE POBLACIÓN='MADRID'

-------

//ELIMINAR ARTÍCULOS DE LA SECCIÓN DEPORTIVOS, CON PRECIO ENTRE 50 Y 100 EUROS:

EN ACCESS >>> DELETE FROM PRODUCTOS WHERE SECCIÓN='DEPORTIVOS' AND PRECIO BETWEEN 50 AND 100

------

//ELIMINAR ARTÍCULOS DE LA SECCCIÓN DE DEPORTES Y CERÁMICA: 

EN ACCESS >>> DELETE FROM PRODUCTOS WHERE SECCIÓN='DEPORTIVOS' OR SECCIÓN='CERÁMICA'

------

//CLIENTES QUE HAN HECHO PEDIDOS:

SELECT EMPRESA FROM CLIENTES INNER JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS .CÓDIGOCLIENTE

//… CON ESTA INSTRUCCIÓN LOS CLIENTES SALEN REPETIDOS SEGÚN LA CANTIDAD DE PEDIDOS DE CADA UNO, 
//…CON DISTINCT APARECERÁ SOLO UN REGISTRO DE CLIENTE(O SEA DE CAMPO)

SELECT DISTINCT EMPRESA FROM CLIENTES INNER JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE

//DISTINCTROW: EVITA LOS REGISTROS REPETIDOS DE TODA UNA FILA.

SELECT DISTINCTROW EMPRESA FROM CLIENTES INNER JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 14
CONSULTAS DE DATOS ANEXADOS

// AGREGAMOS LOS CLIENTES DE MADRID DE LA TABLA CLIENTES_MADRID A LA TABLA CLIENTES:

INSERT INTO CLIENTES 
SELECT * FROM  CLIENTES_MADRID

// AGREGAMOS LOS CLIENTES DE MADRID DE LA TABLA CLIENTES_MADRID A LA TABLA CLIENTES / ESPECIFICAMOS LOS CAMPOS QUE VAMOS A ANEXAR (LOS CAMPOS CLAVE SIEMPRE SE DEBEN INCLUIR)

INSERT INTO CLIENTES (CÓDIGOCLIENTE, EMPRESA, POBLACIÓN, TELÉFONO)
SELECT CÓDIGOCLIENTE, EMPRESA, POBLACIÓN, TELÉFONO FROM CLIENTES_MADRID


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 15
REFERENCIAS CRUZADAS 

//INCLUIMOS NOMBREARTÍCULO, SECCIÓN Y PRECIO:

TRANSFORM SUM(PRECIO) AS TOTAL
SELECT NOMBREARTÍCULO 
FROM PRODUCTOS 
GROUP BY NOMBREARTÍCULO
PIVOT SECCIÓN 

//CUENTA LA CANTIDAD DE ARTÍCULOS(SEGÚN EL PRECIO), CON BARRA LATERAL DE ARTÍCULOS Y BARRA SUPERIOR DE COLUMNAS CON LAS SECCIONES:

TRANSFORM COUNT(PRECIO) AS N_ARTÍCULOS
SELECT NOMBREARTÍCULO
FROM PRODUCTOS
GROUP BY NOMBREARTÍCULO
PIVOT SECCIÓN 

//CUENTA LA CANTIDAD DE ARTÍCULOS(CÓDIGOARTÍCULO), CON BARRA LATERAL DE ARTÍCULOS Y BARRA SUPERIOR DE COLUMNAS CON LAS SECCIONES:

TRANSFORM COUNT(CÓDIGOARTÍCULO) AS N_ARTÍCULOS
SELECT NOMBREARTÍCULO
FROM PRODUCTOS
GROUP BY NOMBREARTÍCULO
PIVOT SECCIÓN 

//HACER CONSULTA CON DOS TABLAS 
//1.-CREAMOS CONSULTA CON INNER JOIN:

SELECT EMPRESA, POBLACIÓN, FORMADEPAGO FROM CLIENTES INNER JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE=PEDIDOS.CÓDIGOCLIENTE

//2.-CREAMOS CONSULTA DE REFERENCIAS CRUZADAS, PERO ESTA VEZ DE LA CONSULTA CON INNER JOIN:

TRANSFORM COUNT(POBLACIÓN) AS TOTAL_FORMAPAGO
SELECT EMPRESA
FROM PREVIA 
GROUP BY  EMPRESA
PIVOT FORMADEPAGO

//CONSULTA DE REFERENCIAS CRUZADAS PERO CON MÁS DE UN CAMPO
//DOS BARRAS LATERALES NOMBREARTÍCULO Y PAÍSDEORIGEN. BARRA SUPERIOR CON LAS SECCIONES:

TRANSFORM SUM(PRECIO) AS TOTAL
SELECT NOMBRERTÍCULO, PAÍSDEORIGEN
FROM PRODUCTOS 
GROUP BY NOMBREARTÍCULO, PAÍSDEORIGEN
PIVOT SECCIÓN 



:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 16
CREACIÓN DE TABLAS
CREATE - ALTER - DROP - TRUNCATE

//MYSQL…  CREAR TABLA CON UN CAMPO DE TIPO VARCHAR CON LONGITUD DE 20 CARACTERES:
CREATE TABLE PRUEBA(NOMBRE VARCHAR(20))

//ACCESS… CREAR TABLA CON UN CAMPO DE TIPO VARCHAR CON LONGITUD DE 20 CARACTERES:
CREATE TABLE PRUEBA(NOMBRE TEXT(20))

//MYSQL… ELIMINA LA TABLA PRUEBA:
DROP TABLE PRUEBA

CREAR TABLA CON VARIOS CAMPOS:

//EN MYSQL >>> 
CREATE TABLE PRUEBA(NOMBRE VARCHAR(20), APELLIDO VARCHAR(20), EDAD TINYINT, FECHA_NACIMIENTO DATE, CARNET BOOL)
CREATE TABLE PRUEBA(ID_ALUMNO INT AUTO_INCREMENT, NOMBRE VARCHAR(20), APELLIDO VARCHAR(20), EDAD TINYINT, FECHA_NACIMIENTO DATE, CARNET BOOL, PRIMARY KEY (ID_ALUMNO))

//EN ACCESS >>>
CREATE TABLE PRUEBA(NOMBRE TEXT(20), APELLIDO TEXT(20), EDAD BYTE, FECHA_NACIMIENTO DATE, CARNET BIT) 
CREATE TABLE PRUEBA(ID_ALUMNO COUNTER, NOMBRE TEXT(20), APELLIDO TEXT(20), EDAD BYTE, FECHA_NACIMIENTO DATE, CARNET BIT) 


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 17
AGREGAR, ELIMINAR Y MODIFICAR DATOS


//EN ACCESS:AGREGAR UNA COLUMNA LLAMADA FECHA_BAJA QUE ALMACENA DATOS DE TIPO DATE:
 
ALTER TABLE CLIENTES_MADRID ADD COLUMN FECHA_BAJA DATE 

//EN ACCESS: ELIMINAR CAMPO POBLACION:

ALTER TABLE CLIENTES_MADRID DROP COLUMN FECHA_BAJA

//MODIFICAR TIPO DE DATO DE UNA COLUMNA:

ALTER TABLE CLIENTES_MADRID ALTER COLUMN FECHA_BAJA VARCHAR(10)

//EN MYSQL: AGREGAMOS UNA COLUMNA LLAMADA POBLACION A LA TABLA PRUEBA. TIENE UNA LONGITUD DE 20, TIPO VARCHAR:

ALTER TABLE PRUEBA ADD COLUMN POBLACION VARCHAR(20)

//EN MYSQL: ELIMINAR CAMPO POBLACIÓN:

ALTER TABLE PRUEBA DROP COLUMN POBLACION

------

//EN MYSQL: ESTABLECER VALOR POR DEFECTO DE UN CAMPO DENTRO DE UNA TABLA:
//EN MYSQL: CREAMOS LA COLUMNA:

ALTER TABLE PRUEBA ADD COLUMN LUGAR_NACIMIENTO VARCHAR(20)

//EN MYSQL: ESTABLECEMOS VALOR POR DEFECTO:

ALTER TABLE PRUEBA ALTER COLUMN LUGAR_NACIMIENTO SET DEFAULT 'DESCONOCIDO'

//EN MYSQL: ELIMINAMOS VALOR POR DEFECTO:

ALTER TABLE PRUEBA ALTER COLUMN LUGAR_NACIMIENTO DROP DEFAULT

-------

//EN ACCESS: ESTABLECER VALOR POR DEFECTO DEL CAMPO EMPRESA:
ALTER TABLE CLIENTES_MADRID ALTER COLUMN EMPRESA SET DEFAULT 'DESCONOCIDO'


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 18
INDICES


EN ACCESS: CREAMOS UNA TABLA CON CAMPO CLAVE: 

CREATE TABLE EJEMPLO(DNI TEXT, NOMBRE TEXT, APELLIDO TEXT, EDAD NUMBER, PRIMARY KEY(DNI)) 

EN ACCESS: LE AGREGAMOS EL CAMPO CLAVE A UNA TABLA, DESPUÉS DE HABERLA CREADO:

ALTER TABLE EJEMPLO ADD PRIMARY KEY(DNI)

EN ACCESS: (INDICE PRIMARIO MULTICAMPO) UNA TABLA CON DOS CAMPOS CLAVE, O SEA UN ÍNDICE FORMADO POR DOS CAMPOS:

ALTER TABLE EJEMPLO ADD PRIMARY KEY(NOMBRE, APELLIDO)

------

//INDICES ORDINARIOS 
//EN ACCESS: CREACION DE INDICE ORDINARIO EN EL CAMPO APELLIDO:

CREATE INDEX MIINDICE ON EJEMPLO (APELLIDO)

------

//INDICES ÚNICOS
//EN ACCESS:

CREATE UNIQUE INDEX MIINDICE ON EJEMPLO(APELLIDO)

//LOS CAMPOS NO PODRÁN TENER EL MISMO NOMBRE Y APELLIDO: 

CREATE UNIQUE INDEX MIINDICE ON EJEMPLO(NOMBRE, APELLIDO)


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 19
ELIMINAR INDICES

//ELIMINAR ÍNDICES
//LO CREAMOS:

CREATE INDEX MIINDICE ON EJEMPLO (DNI)

//LO ELIMINAMOS :
DROP INDEX MIINDICE ON EJEMPLO (DNI)

----

//ELIMINAR ÍNDIDE CUANDO TAMBIÉN ES UNA CLAVE PRIMARIA:
//AGREGAMOS CLAVE PRINCIPAL:

ALTER TABLE  EJEMPLO ADD PRIMARY KEY (DNI)

//ELIMINAMOS:
EN ACCESS >>> ALTER TABLE EJEMPLO DROP CONSTRAINT codigoDeClavePrimariaQueLeDioAccess
EN MYSQL  >>> ALTER TABLE EJEMPLO DROP PRIMARY KEY


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 20
TRIGGERS

(IMAGEN: TRIGGERS)
(IMAGEN: EJECUCION DE LOS TRIGGERS; INSERTAR, ACTUALIZAR Y ELIMINAR / BEFORE OR AFTER)


//EN MYSQL:
//CREAMOS TABLA:
//INSERTADO: CAMPO PARA ALMACENAR EL MOMENTO EN QUE SE HA INSERTADO UN REGISTRO.

CREATE TABLE REG_PRODUCTOS (CÓDIGOARTÍCULO VARCHAR(25), NOMBREARTÍCULO VARCHAR(30), PRECIO INT(4), INSERTADO DATETIME)

//CREAMOS TRIGGER:

//PRODUCTOS: SE PONE LA TABLA A LA QUE ESTÁ ASOCIADO EL TRIGGER.
//_A : SIGNIFICA AFTER. O SEA QUE EL TRIGGER VA DESPUÉS DE LA OPERACIÓN QUE SE VA A REALIZAR.
// I : DE INSERT.
// U : DE UPDATE.   
// D : DE DELETE.
// AFTER: INDICAMOS SI LA OPERACIÓN SERA ANTES O DESPUÉS.
// FOR EACH ROW :  LA INSTRUCCIÓN SE EJECUTARÁ POR CADA FILA DE REGISTRO QUE INSERTEMOS.
// FOR EACH STATEMENT : LA INSTRUCCIÓN SE EJECUTARÁ POR CADA SENTENCIA QUE EJECUTEMOS.
// INSERT INTO REG_PRODUCTOS (……..)  :   LE DECIMOS AL TRIGGER QUE: INSERTE EN LA TABLA REG_PRODUCTOS, LOS REGISTROS INSERTADOS EN PRODUCTOS.
// NEW : HACE REFERENCIA AL NUEVO VALOR QUE LE ESTAMOS DANDO A ESTE ARTÍCULO.
// NOW (): FUNCIÓN NOW, PONEMOS EL MOMENTOS EXACTO DE LA ACCIÓN. 

CREATE TRIGGER PRODUCTOS_AI AFTER INSERT ON PRODUCTOS FOR EACH ROW INSERT INTO REG_PRODUCTOS
(CÓDIGOARTÍCULO, NOMBREARTÍCULO, PRECIO, INSERTADO) VALUES (NEW.CÓDIGOARTÍCULO, NEW.NOMBREARTÍCULO, NEW.PRECIO, NOW()) 

//INSTRUCCIÓN DE PRUEBA DEL TRIGGER:
INSERT INTO PRODUCTOS (CÓDIGOARTÍCULO, NOMBREARTÍCULO, PRECIO, PAÍSDEORIGEN) VALUES('AR75', 'PANTALÓN', 50, 'ESPAÑA') 
     

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 21 
TRIGGERS II

TRIGGER DE ACTUALIZACIÓN

(IMAGEN: TRIGGER DE ACTUALIZACIÓN)


//CREAMOS UNA TABLA PARA ALMACENAR LOS DATOS ANTERIORES Y LOS DATOS NUEVOS:


CREATE TABLE PRODUCTOS_ACTUALIZADOS 
(ANTERIOR_CÓDIGOARTÍCULO VARCHAR (4), ANTERIOR_NOMBREARTÍCULO VARCHAR (25), ANTERIOR_SECCIÓN VARCHAR(15),
ANTERIOR_PRECIO INT(4), ANTERIOR_IMPORTADO VARCHAR(15), ANTERIOR_PAÍSORIGEN VARCHAR(15), 
ANTERIOR_FECHA DATE, NUEVO_CÓDIGOARTÍCULO VARCHAR(4), NUEVO_NOMBREARTÍCULO VARCHAR(25), 
NUEVO_SECCIÓN VARCHAR(15), NUEVO_PRECIO INT(4), NUEVO_IMPORTADO VARCHAR(15), NUEVO_PAÍSDEORIGEN VARCHAR(15), 
NUEVO_FECHA DATE, USUARIO VARCHAR(15), F_MODIF DATE) 


//POSTERIORMENTE CREAMOS EL TRIGGER QUE ALMACENARÁ LOS DATOS ANTIGUOS Y NUEVOS EN LA TABLA:
//ACTUALIZA_PRODUCTOS_BU : NOMBRE DEL TRIGGER. SE PONE 'BU' POR BEFORE UPDATE.

CREATE TRIGGER ACTUALIZA_PRODUCTOS_BU BEFORE UPDATE ON PRODUCTOS FOR EACH ROW INSERT INTO PRODUCTOS_ACTUALIZADOS
(ANTERIOR_CÓDIGOARTÍCULO, ANTERIOR_FECHA, ANTERIOR_IMPORTADO, ANTERIOR_NOMBREARTÍCULO, ANTERIOR_PAÍSDEORIGEN, ANTERIOR_PRECIO, ANTERIOR_SECCIÓN,  
NUEVO_CÓDIGOARTÍCULO, NUEVO_FECHA, NUEVO_IMPORTADO, NUEVO_NOMBREARTÍCULO, NUEVO_PAÍSDEORIGEN, NUEVO_PRECIO, NUEVO_SECCIÓN, USUARIO, F_MODIF) 
VALUES
(OLD.CÓDIGOARTÍCULO, OLD.FECHA, OLD.IMPORTADO, OLD.NOMBREARTÍCULO, OLD.PAÍSDEORIGEN, OLD.PRECIO, OLD.SECCIÓN,
NEW.CÓDIGOARTÍCULO, NEW.FECHA, NEW.IMPORTADO, NEW.NOMBREARTÍCULO, NEW.PAÍSDEORIGEN, NEW.PRECIO, NEW.SECCIÓN,
CURRENT_USER(), NOW())


//AHORA CREAMOS UNA CONSULTA DE ACTUALIZACIÓN PARA USAR EL TRIGGER:

UPDATE PRODUCTOS SET PRECIO=PRECIO+20 WHERE CÓDIGOARTÍCULO='AR07'


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 22
TRIGGER DE ELIMINACIÓN / ELIMINACIÓN DE TRIGGERS / MODIFICACIÓN DE TRIGGERS 

//CREAMOS UNA TABLA PARA ALMACENAR LA INFORMACIÓN ELIMINADA:

CREATE TABLE PROD_ELIMINADOS (C_ART VARCHAR(5), NOMBRE VARCHAR(15), SECCIÓN VARCHAR(15), PRECIO INTEGER, PAÍS_ORIGEN VARCHAR(15)) 

//CREAMOS EL TRIGGER DE ELIMINACIÓN:

CREATE TRIGGER ELIMPROD_AD AFTER DELETE ON PRODUCTOS FOR EACH ROW 
INSERT INTO  PROD_ELIMINADOS (C_ART, NOMBRE, PAÍS_ORIGEN, PRECIO, SECCIÓN)
VALUES (OLD.CÓDIDIGOARTÍCULO, OLD.NOMBREARTÍCULO, OLD.PAÍSDEORIGEN, OLD.PRECIO, OLD.SECCIÓN)

//AHORA CREAMOS LA INSTRUCCIÓN PARA ELIMIANR UN REGISTRO:

DELETE FROM PRODUCTOS WHERE CÓDIGOARTÍCULO='AR41'


//AGREGAMOS 2 CAMPOS A LA TABLA PROD_ELIMINADOS:

ALTER TABLE PROD_ELIMINADOS ADD COLUMN (USUARIO VARCHAR(15), FECHA_MODIF DATE)

//ELIMINAMOS OTRO ARTÍCULO, PARA VER QUE QUEDE REGISTRADO EL USUARIO Y LA FECHA:

DELETE FROM PRODUCTOS WHERE CÓDIGOARTÍCULO='AR40'

-------------

//CÓMO ELIMINAR UN TRIGGER CON CÓDIGO EN CONSOLA:

DROP TRIGGER ELIMPROD_AD

//LUEGO LO VOLVEMOS A CREAR
…

//LO VOLVEMOS A ELIMINAR Y CREAR:

DROP TRIGGER IF EXIST ELIM_PROD_AD;  
CREATE TRIGGER ELIMPROD_AD AFTER DELETE ON PRODUCTOS FOR EACH ROW 
INSERT INTO PROD_ELIMINADOS (C_ART, NOMBRE, PAÍS_ORIGEN, PRECIO, SECCIÓN)
VALUES (OLD.CÓDIDIGOARTÍCULO, OLD.NOMBREARTÍCULO, OLD.PAÍSDEORIGEN, OLD.PRECIO, OLD.SECCIÓN)


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 23
PROCEDIMIENTOS ALMACENADOS 
(LOS PROCEDIMIENTOS SON POR ASÍ DECIR, MÉTODOS DONDE ALMACENAR BLOQUES DE CÓDIGO)

CREATE PROCEDURE MUESTRA_CLIENTES() 
SELECT * FROM CLIENTES WHERE POBLACIÓN='MADRID'

//CREAR PROCEDIMIENTO QUE RECIBE  PARÁMETROS (PRECIO NUEVO DE TIPO INT , CÓDIGO DEL ARTÍCULO):
 
CREATE PROCEDURE ACTUALIZA_PRODUCTOS (N_PRECIO INT, CÓDIGO VARCHAR(4))
UPDATE PRODUCTOS SET PRECIO=N_PRECIO WHERE CÓDIGOARTÍCULO=CÓDIGO; 


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 24
PROCEDIMIENTOS ALMACENADOS Y TRIGGERS

//PROCEDIMIENTO ALMACENADO QUE CALCULA LA EDAD EN FUNCIÓN DEL AÑO DE NACIMIENTO QUE LE PASAMOS POR PARÁMETRO:

//BEGIN Y END :  ESTRUCTURAS QUE DETERMINAN LAS LÍNEAS DE EJECUCIÓN, CUANDO HAY MÁS DE UN BLOQUE DE EJECUCIÓN DENTRO DE UNA FUNCIÓN. 
//DECLARE : PARA DECLARAR VARIABLES
//SELECT : AQUÍ SELECT ES LO MISMO QUE UN RETURN.
//DELIMITER : ES PARA DELIMITAR EL BLOQUE. ESTE VA AL PRINCIPIO Y SE ESTABLECE EL SIGNO DEL DELIMITADOR.
//"DELIMITER ;"  : AL FINAL TENEMOS QUE RESETEAR EL DELIMITADOR.


DELIMITER $$
CREATE PROCEDURE CALCULA_EDAD (AGNO_NACIMIENTO INT)
	BEGIN
		DECLARE AGNO_ACTUAL INT  DEFAULT 2016;
		DECLARE EDAD INT;
		SET EDAD = AGNO_ACTUAL - AGNO_NACIMIENTO;
		SELECT EDAD;
	END;$$ 
DELIMITER ;


-----------------------


//CREAMOS UN TRIGGER CON UN BLOQUE DE CÓDIGO IF / IF ELSE EN EL INTERIOR:
//SI EL PRECIO ES MENOR QUE CERO, LO DEJA EN 0.
//SI EL PRECIO ES MAYOR A 1000, DEJALO EN 1000. 


DELIMITER $$
CREATE TRIGGER REVISA_PRECIO_BU BEFORE UPDATE ON PRODUCTOS FOR EACH ROW 
	BEGIN
		IF(NEW.PRECIO<0) THEN
			SET NEW.PRECIO=0;
		ELSEIF(NEW.PRECIO>1000) THEN
			SET NEW.PRECIO=1000;
		END IF;
	END; $$
DELIMITER ;


//LUEGO CAMBIAMOS EL PRECIO DE UN ARTÍCULO:

UPDATE PRODUCTOS SET PRECIO=15 WHERE CÓDIGOARTÍCULO='AR01' 

//AHORA, CON EL TRIGGER Y ESTA INSTRUCCIÓN,  EL PRECIO DEL PRODUCTO SOLO QUEDARÁ EN 1000 EUROS:

UPDATE PRODUCTOS SET PRECIO=8500 WHERE CÓDIGOARTÍCULO='AR01' 

//VOLVEMOS A PONER EL PRECIO ORIGINAL DEL PRODUCTO:

UPDATE PRODUCTOS SET PRECIO=6.83 WHERE CÓDIGOARTÍCULO='AR01' 

//MODIFICAMOS EL TRIGGER Y LE DEDIMOS..
//QUE SI EL PRECIO ES MENOR QUE CERO O MAYOR A 1000 EUROS, DEJA EL PRECIO COMO ESTÁ.

:

DELIMITER $$
CREATE TRIGGER REVISA_PRECIO_BU BEFORE UPDATE ON PRODUCTOS FOR EACH ROW 
	BEGIN
		IF(NEW.PRECIO<0) THEN
			SET NEW.PRECIO=OLD.PRECIO;
		ELSEIF(NEW.PRECIO>1000) THEN
			SET NEW.PRECIO=OLD.PRECIO;
		END IF;
	END; $$
DELIMITER ;


//VOLVEMOS A EJECUTAR UNA CONSULTA DE TIPO UPDATE:

UPDATE PRODUCTOS SET PRECIO=8500 WHERE CÓDIGOARTÍCULO='AR01' 


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


CLASE 25 
VISTAS

//VISTA QUE NOS MUESTRA NOMBREARTÍCULO, SECCIÓN  Y PRECIO,  Y QUE NOS MUESTRE LOS ARTÍCULOS DE LA SECCIÓN DE DEPORTES:

CREATE VIEW ART_DEPORTES AS 
SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM PRODUCTOS 
WHERE SECCIÓN = 'DEPORTES'

//HACEMOS UN UPDATE PARA VER EL CAMBIO EN LA VISTA RECIÉN HECHA:

UPDATE PRODUCTOS SET PRECIO=PRECIO+10
WHERE NOMBREARTÍCULO = 'RAQUETA TENIS' 

-------

//CREAMOS OTRA VISTA DE CERÁMICAS:

CREATE VIEW ART_CERÁMICA AS 
SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM PRODUCTOS 
WHERE SECCIÓN='CERÁMICA'  

------

//ELIMINAMOS LA VISTA DE CERÁMICAS:

DROP VIEW ART_CERÁMICAS

------

//MODIFICAMOS LA VISTA DE ARTICULOS DE DEPORTE:

ALTER VIEW ART_DEPORTES AS
SELECT NOMBREARTÍCULO, SECCIÓN, PAÍSDEORIGEN FROM PRODUCTOS 
WHERE PAÍSDEORIGEN='ESPAÑA'


:::::::::::::::::::::::::::::::::::::::::::::::::FIN DEL CURSO DE SQL / PÍLDORAS INFORMÁTICAS:::::::::::::::::::::::::::::::::::::::::::::::::::::

